<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Minneapolis Chain of Lakes – Ice Report</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Leaflet (map) -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />

  <style>
    :root {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #0b1720;
      color: #f2f6fb;
      --accent: #33c3ff;
      --accent-soft: rgba(51, 195, 255, 0.12);
      --card-bg: rgba(9, 23, 36, 0.95);
      --border-subtle: rgba(255, 255, 255, 0.06);
      --danger: #ff4f6a;
      --warn: #ffc857;
      --safe: #4cd964;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
    }

    header {
      padding: 1.5rem 1.5rem 0.75rem;
      border-bottom: 1px solid var(--border-subtle);
      background: radial-gradient(circle at top, #102b3f 0, #050b11 60%);
    }

    .title {
      display: flex;
      flex-wrap: wrap;
      align-items: baseline;
      gap: 0.5rem;
    }

    .title h1 {
      margin: 0;
      font-size: clamp(1.5rem, 2vw + 1rem, 2.2rem);
      letter-spacing: 0.02em;
    }

    .title span.badge {
      font-size: 0.8rem;
      padding: 0.15rem 0.6rem;
      border-radius: 999px;
      border: 1px solid var(--accent);
      background: var(--accent-soft);
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }

    header p {
      margin: 0.5rem 0 0;
      max-width: 40rem;
      color: rgba(255,255,255,0.8);
      font-size: 0.95rem;
    }

    .dataset-switcher {
      margin-top: 0.75rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      align-items: center;
      font-size: 0.85rem;
    }

    .dataset-switcher label {
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: rgba(255,255,255,0.7);
      font-size: 0.75rem;
    }

    .dataset-switcher select {
      border-radius: 999px;
      border: 1px solid var(--border-subtle);
      padding: 0.2rem 0.75rem;
      background: rgba(4,12,20,0.9);
      color: #f9fbff;
      font-size: 0.85rem;
    }

    .header-controls {
      margin-top: 0.75rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      align-items: center;
      font-size: 0.85rem;
    }

    .header-controls .control {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
    }

    .header-controls label {
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: rgba(255,255,255,0.7);
      font-size: 0.75rem;
    }

    .header-controls select {
      border-radius: 999px;
      border: 1px solid var(--border-subtle);
      padding: 0.2rem 0.75rem;
      background: rgba(4,12,20,0.9);
      color: #f9fbff;
      font-size: 0.85rem;
    }

    main {
      flex: 1;
      padding: 1.5rem;
      max-width: 1200px;
      width: 100%;
      margin: 0 auto;
    }

    .tabs {
      margin-bottom: 1rem;
      display: inline-flex;
      border-radius: 999px;
      background: rgba(0,0,0,0.4);
      border: 1px solid var(--border-subtle);
      padding: 0.2rem;
    }

    .tab-button {
      border: none;
      background: transparent;
      color: rgba(255,255,255,0.75);
      padding: 0.4rem 1rem;
      border-radius: 999px;
      font-size: 0.9rem;
      cursor: pointer;
      transition: background 0.15s, color 0.15s;
      white-space: nowrap;
    }

    .tab-button.active {
      background: var(--accent);
      color: #021018;
    }

    .status-bar {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      align-items: center;
      margin: 1rem 0 1.5rem;
    }

    .status-pill {
      padding: 0.4rem 0.75rem;
      border-radius: 999px;
      font-size: 0.8rem;
      border: 1px solid var(--border-subtle);
      background: rgba(0,0,0,0.35);
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
    }

    .status-pill strong {
      font-weight: 600;
    }

    .status-dot {
      width: 0.55rem;
      height: 0.55rem;
      border-radius: 50%;
      background: var(--safe);
    }

    .status-dot.warn { background: var(--warn); }
    .status-dot.danger { background: var(--danger); }

    .filters {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      align-items: center;
      margin-bottom: 1.25rem;
    }

    .filters label {
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: rgba(255,255,255,0.7);
    }

    .filters select,
    .filters input[type="date"],
    .filters input[type="search"] {
      border-radius: 999px;
      border: 1px solid var(--border-subtle);
      padding: 0.35rem 0.8rem;
      background: rgba(4,12,20,0.9);
      color: #f9fbff;
      font-size: 0.85rem;
      min-width: 8rem;
    }

    .filters-group {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .summary-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
      gap: 0.75rem;
      margin-bottom: 1.5rem;
    }

    .lake-card {
      border-radius: 1rem;
      border: 1px solid var(--border-subtle);
      padding: 0.75rem 0.85rem;
      background: var(--card-bg);
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
    }

    .lake-header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 0.5rem;
    }

    .lake-name {
      font-weight: 600;
      font-size: 0.95rem;
    }

    .lake-date {
      font-size: 0.75rem;
      color: rgba(255,255,255,0.6);
    }

    .thickness {
      font-size: 1.2rem;
    }

    .thickness span.unit {
      font-size: 0.75rem;
      color: rgba(255,255,255,0.7);
      margin-left: 0.2rem;
    }

    .safety-tag {
      font-size: 0.75rem;
      padding: 0.1rem 0.55rem;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(0,0,0,0.3);
    }

    .safety-tag.safe {
      border-color: var(--safe);
      color: var(--safe);
    }
    .safety-tag.caution {
      border-color: var(--warn);
      color: var(--warn);
    }
    .safety-tag.unsafe {
      border-color: var(--danger);
      color: var(--danger);
    }

    .lake-meta {
      font-size: 0.75rem;
      color: rgba(255,255,255,0.7);
    }

    .description {
      font-size: 0.8rem;
      color: rgba(255,255,255,0.8);
      margin-top: 0.25rem;
      white-space: pre-line;
    }

    .table-wrapper {
      border-radius: 1rem;
      border: 1px solid var(--border-subtle);
      background: var(--card-bg);
      overflow: hidden;
      margin-top: 1.25rem;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.85rem;
    }

    thead {
      background: rgba(5,15,25,0.95);
    }

    thead th {
      padding: 0.6rem 0.75rem;
      text-align: left;
      border-bottom: 1px solid var(--border-subtle);
      text-transform: uppercase;
      letter-spacing: 0.08em;
      font-size: 0.7rem;
      color: rgba(255,255,255,0.7);
      cursor: pointer;
      user-select: none;
    }

    tbody tr:nth-child(even) {
      background: rgba(0,0,0,0.35);
    }

    tbody td {
      padding: 0.55rem 0.75rem;
      border-bottom: 1px solid rgba(255,255,255,0.04);
    }

    .table-scroll {
      max-height: 420px;
      overflow: auto;
    }

    .map-card,
    .chart-card,
    .download-card {
      border-radius: 1rem;
      border: 1px solid var(--border-subtle);
      background: var(--card-bg);
      padding: 0.9rem 0.95rem 1rem;
      margin-bottom: 1.5rem;
    }

    .map-card h2,
    .chart-card h2,
    .download-card h2 {
      margin: 0 0 0.25rem;
      font-size: 1rem;
    }

    .map-note,
    .chart-card p,
    .download-card p {
      margin: 0.15rem 0 0.5rem;
      font-size: 0.8rem;
      color: rgba(255,255,255,0.75);
    }

    .map-container {
      width: 100%;
      height: 260px;
      border-radius: 0.75rem;
      overflow: hidden;
      margin-top: 0.4rem;
    }

    .chart-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.75rem;
      margin-bottom: 0.5rem;
    }

    .chart-header-text {
      flex: 1;
    }

    #chart-lake-select {
      border-radius: 999px;
      border: 1px solid var(--border-subtle);
      padding: 0.35rem 0.8rem;
      background: rgba(4,12,20,0.9);
      color: #f9fbff;
      font-size: 0.85rem;
    }

    .download-card ul {
      list-style: none;
      padding-left: 0;
      margin: 0 0 0.4rem;
      font-size: 0.85rem;
    }

    .download-card li + li {
      margin-top: 0.25rem;
    }

    .download-card a {
      color: var(--accent);
      text-decoration: none;
    }

    .download-card a:hover {
      text-decoration: underline;
    }

    .download-note {
      font-size: 0.75rem;
      color: rgba(255,255,255,0.6);
    }

    footer {
      padding: 0.9rem 1.5rem 1.1rem;
      border-top: 1px solid var(--border-subtle);
      font-size: 0.75rem;
      color: rgba(255,255,255,0.7);
      background: #050b11;
    }

    footer a {
      color: var(--accent);
      text-decoration: none;
    }

    footer a:hover {
      text-decoration: underline;
    }

    @media (max-width: 640px) {
      header {
        padding: 1rem;
      }
      main {
        padding: 1rem;
      }
      .filters {
        flex-direction: column;
        align-items: stretch;
      }
      .status-bar {
        flex-direction: column;
        align-items: flex-start;
      }
      .chart-header {
        flex-direction: column;
        align-items: flex-start;
      }
      #chart-lake-select {
        width: 100%;
      }
    }
  </style>
</head>
<body>
<header>
  <div class="title">
    <h1>Minneapolis Chain of Lakes – Ice Report</h1>
    <span class="badge">Multi-season</span>
  </div>
  <p>
    Weekly ice thickness measurements around the Chain of Lakes. This page shows the
    latest readings and lets you explore historical data by lake and date. Always
    double-check conditions in person before going on the ice.
  </p>

  <div class="dataset-switcher">
    <label for="dataset-select">Dataset:</label>
    <select id="dataset-select">
      <option value="ice2025">Main season 2025–26</option>
      <option value="ice2024">Main season 2024–25</option>
      <option value="preice2025">Pre-ice-in 2025</option>
    </select>
  </div>

  <div class="header-controls">
    <div class="control">
      <label for="unit-select" data-i18n="label_units">Units:</label>
      <select id="unit-select">
        <option value="cm">cm</option>
        <option value="in">in</option>
      </select>
    </div>
    <div class="control">
      <label for="lang-select" data-i18n="label_language">Language:</label>
      <select id="lang-select">
        <option value="en">English</option>
        <option value="es">Español</option>
        <option value="fr">Français</option>
        <option value="hmn">Hmoob</option>
        <option value="so">Soomaali</option>
        <option value="ar">العربية</option>
        <option value="arc">ܐܪܡܝܐ (Aramaic)</option>
      </select>
    </div>
  </div>

</header>

<main>
  <div class="tabs" role="tablist">
    <button class="tab-button active" data-tab="currentSeason" type="button">Current season</button>
    <button class="tab-button" data-tab="current" type="button">Selected dataset status</button>
    <button class="tab-button" data-tab="history" type="button">History &amp; all readings</button>
  </div>

  <!-- Current season (always Ice2025) -->
  <section id="currentSeason" class="tab-panel" role="tabpanel">
    <div class="status-bar">
      <div class="status-pill">
        <span class="status-dot" id="season-latest-status-dot"></span>
        <span>Current season (2025–26) latest: <strong id="season-latest-date-label">–</strong></span>
      </div>
      <div class="status-pill">
        Safety legend:
        <span class="status-dot danger"></span><span>Thin / unsafe</span>
        <span class="status-dot warn" style="margin-left:0.5rem;"></span><span>Use caution</span>
        <span class="status-dot safe" style="margin-left:0.5rem;"></span><span>Thicker</span>
      </div>
    </div>

    <div class="summary-grid" id="current-season-grid">
      <!-- Cards injected by JS -->
    </div>
  </section>

  <!-- Current status for selected dataset -->
  <section id="current" class="tab-panel" role="tabpanel" hidden>
    <div class="status-bar">
      <div class="status-pill" id="latest-date-pill">
        <span class="status-dot" id="latest-status-dot"></span>
        <span>Latest measurements in selected dataset: <strong id="latest-date-label">–</strong></span>
      </div>
      <div class="status-pill">
        Safety legend:
        <span class="status-dot danger"></span><span>Thin / unsafe</span>
        <span class="status-dot warn" style="margin-left:0.5rem;"></span><span>Use caution</span>
        <span class="status-dot safe" style="margin-left:0.5rem;"></span><span>Thicker</span>
      </div>
    </div>

    <div class="filters" aria-label="Current status filters">
      <div class="filters-group">
        <label for="current-lake-filter">Filter by lake</label>
        <select id="current-lake-filter">
          <option value="all">All lakes</option>
        </select>
      </div>
      <div class="filters-group">
        <label for="search-filter">Search</label>
        <input type="search" id="search-filter" placeholder="Search lake or notes…" />
      </div>
    </div>

    <div class="summary-grid" id="current-grid">
      <!-- Cards injected by JS -->
    </div>

    <div class="map-card">
      <h2>Map – latest measurement by lake (selected dataset)</h2>
      <p class="map-note">Pins show the most recent reading for each lake in the selected dataset. Tap a pin for details.</p>
      <div id="map" class="map-container"></div>
    </div>
  </section>

  <!-- History & all readings -->
  <section id="history" class="tab-panel" role="tabpanel" hidden>
    <div class="chart-card">
      <div class="chart-header">
        <div class="chart-header-text">
          <h2>Ice growth by lake</h2>
          <p>Pick a lake to see how ice thickness changed over the season (selected dataset).</p>
        </div>
        <select id="chart-lake-select">
          <option value="">Select a lake…</option>
        </select>
      </div>
      <canvas id="lake-chart" height="180"></canvas>
    </div>

    <div class="filters" aria-label="History filters">
      <div class="filters-group">
        <label for="history-lake-filter">Lake</label>
        <select id="history-lake-filter">
          <option value="all">All lakes</option>
        </select>
      </div>
      <div class="filters-group">
        <label for="history-date-from">From date</label>
        <input type="date" id="history-date-from" />
      </div>
      <div class="filters-group">
        <label for="history-date-to">To date</label>
        <input type="date" id="history-date-to" />
      </div>
    </div>

    <div class="table-wrapper">
      <div class="table-scroll">
        <table>
          <thead>
            <tr>
              <th data-sort="date">Date</th>
              <th data-sort="lake">Lake</th>
              <th>Lat</th>
              <th>Long</th>
              <th data-sort="thickness_cm">Thickness</th>
              <th>Notes</th>
            </tr>
          </thead>
          <tbody id="history-tbody">
            <!-- Rows injected by JS -->
          </tbody>
        </table>
      </div>
    </div>

    <div class="download-card">
      <h2>Download ice data (Excel)</h2>
      <p>You can download the original Excel files used to build this site.</p>
      <ul id="excel-download-list"></ul>
      <p class="download-note">
        Tip: right-click a file and choose “Save link as…” if your browser tries to open it instead of downloading.
      </p>
    </div>
  </section>
</main>

<footer>
  Data collected by hand. This website is for informational and
  educational purposes only; always check local conditions and use proper safety
  gear before going on the ice.
</footer>

<!-- Leaflet JS -->
<script
  src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
  integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
  crossorigin=""
></script>

<!-- Chart.js -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

<script>
  // Datasets available on the site
  const datasetConfigs = {
    ice2024: {
      csv: "https://docs.google.com/spreadsheets/d/10ll9xieEsBvNVRCbrzX_40V6qi-ZYN76Q6e7ScaiS_k/export?format=csv&gid=0",
      json: "Ice2024.json",
      labelShort: "2024–25"
    },
    ice2025: {
      csv: "https://docs.google.com/spreadsheets/d/10smiQBJ8mBWax24aOagG9LdzrrnhFmj0tfRESunUJNI/export?format=csv&gid=0",
      json: "Ice2025.json",
      labelShort: "2025–26"
    },
    preice2025: {
      csv: "https://docs.google.com/spreadsheets/d/1bCuw9eC3rEUfVleZLPOt3sJh7c09SeFPCfxiuuVGuyI/export?format=csv&gid=0",
      json: "Pre-ice-in-2025.json",
      labelShort: "Pre-ice-in 2025"
    }
  };

  // --- Google Sheets CSV support ---
  // Simple CSV parser: good for numeric/text cells without embedded commas.
  // If you start using commas inside description cells, we can upgrade this to a quote-aware parser.
  function normalizeHeader(h) {
    return String(h || "")
      .trim()
      .toLowerCase()
      .replace(/\s+/g, "_")
      .replace(/[()]/g, "")
      .replace(/[^a-z0-9_]/g, "");
  }

  // RFC4180-ish parser (handles quoted commas/newlines)
  function parseCsvToObjects(text) {
    const rows = [];
    let row = [];
    let field = "";
    let inQuotes = false;

    for (let i = 0; i < text.length; i++) {
      const c = text[i];
      const next = text[i + 1];

      if (inQuotes) {
        if (c === '"' && next === '"') { field += '"'; i++; continue; }
        if (c === '"') { inQuotes = false; continue; }
        field += c;
      } else {
        if (c === '"') { inQuotes = true; continue; }
        if (c === ",") { row.push(field); field = ""; continue; }
        if (c === "\r") continue;
        if (c === "\n") { row.push(field); rows.push(row); row = []; field = ""; continue; }
        field += c;
      }
    }
    row.push(field);
    rows.push(row);

    while (rows.length && rows[rows.length - 1].every(x => (x ?? "").trim() === "")) rows.pop();
    if (!rows.length) return [];

    const headers = rows[0].map(h => normalizeHeader((h ?? "").trim()));
    const out = [];
    for (let r = 1; r < rows.length; r++) {
      const cols = rows[r];
      if (!cols || cols.every(x => (x ?? "").trim() === "")) continue;
      const obj = {};
      headers.forEach((h, idx) => obj[h] = (cols[idx] ?? "").trim());
      out.push(obj);
    }
    return out;
  }
    return rows;
  }

  function coalesce(obj, keys) {
    for (const k of keys) {
      const v = obj[k];
      if (v !== undefined && v !== null && String(v).trim() !== "") return String(v).trim();
    }
    return "";
  }

  function parseCoordinatesToLatLong(coordStr) {
    if (!coordStr) return { lat: "", long: "" };
    const s = String(coordStr).trim();

    const simple = s.match(/^\s*([+-]?\d+(?:\.\d+)?)\s*,\s*([+-]?\d+(?:\.\d+)?)\s*$/);
    if (simple) return { lat: simple[1], long: simple[2] };

    const m = s.match(/([0-9]+(?:\.[0-9]+)?)\s*°?\s*([NS])[^0-9]*([0-9]+(?:\.[0-9]+)?)\s*°?\s*([EW])/i);
    if (m) {
      let lat = parseFloat(m[1]);
      let lon = parseFloat(m[3]);
      if (m[2].toUpperCase() === "S") lat = -lat;
      if (m[4].toUpperCase() === "W") lon = -lon;
      return { lat: String(lat), long: String(lon) };
    }

    const nums = s.match(/[-+]?\d+(?:\.\d+)?/g);
    if (nums && nums.length >= 2) return { lat: nums[0], long: nums[1] };
    return { lat: "", long: "" };
  }

  // Handles your three header schemas:
  // Ice2024: date,lake,lat_dd,long_dd,thickness_in,description,Thickness_cm
  // Ice2025: Date,Lake,Coordinates,Thickness (Inches),Info,Thickness (cm)
  // Pre-ice-in: Date,Lake,Temp,Lat,Long
  function normalizeRow(row) {
    const date = coalesce(row, ["date", "measurement_date", "timestamp"]);
    const lake = coalesce(row, ["lake", "waterbody", "body_of_water", "name"]);

    let lat = coalesce(row, ["lat", "lat_dd", "latitude"]);
    let lon = coalesce(row, ["long", "long_dd", "lon", "longitude", "lng"]);

    if (!lat || !lon) {
      const coord = coalesce(row, ["coordinates", "coordinate", "coords", "location"]);
      const parsed = parseCoordinatesToLatLong(coord);
      lat = lat || parsed.lat;
      lon = lon || parsed.long;
    }

    let thickness_cm = coalesce(row, ["thickness_cm", "thicknesscm"]);
    const thickness_in = coalesce(row, ["thickness_in", "thickness_inches"]);
    if (!thickness_cm && thickness_in) {
      const inches = parseFloat(String(thickness_in).replace(/[^0-9.\-]/g, ""));
      if (!isNaN(inches)) thickness_cm = String(inches * 2.54);
    }

    const temp = coalesce(row, ["temp", "temperature", "air_temp", "water_temp"]);
    let description = coalesce(row, ["description", "info", "notes", "note", "comments", "comment"]);
    if (!description && temp) description = `Temp: ${temp}`;

    return { date, lake, lat, long: lon, thickness_cm, description, temp };
  }

  async function fetchDataset(cfg) {
    if (cfg.csv) {
      try {
        const resp = await fetch(cfg.csv, { cache: "no-store" });
        const text = await resp.text();
        const firstChunk = text.slice(0, 300).toLowerCase();
        const looksLikeHtml =
          firstChunk.includes("<html") ||
          firstChunk.includes("<!doctype") ||
          firstChunk.includes("accounts.google.com") ||
          firstChunk.includes("sign in");

        if (resp.ok && !looksLikeHtml) {
          const raw = parseCsvToObjects(text);
          const normalized = raw.map(normalizeRow).filter(r => r.date && r.lake);
          if (normalized.length) return normalized;
        }
      } catch (e) {
        console.warn("CSV fetch failed:", e);
      }
    }

    if (!cfg.json) throw new Error("No dataset source available (csv/json).");
    const resp = await fetch(cfg.json, { cache: "no-store" });
    const json = await resp.json();
    return json.map(normalizeRow).filter(r => r.date && r.lake);
  }
    }
    const resp = await fetch(cfg.json);
    return await resp.json();
  }


  // Excel files available for download
  const excelFiles = [
    { file: "Ice2024.xlsx",       label: "Ice thickness 2024–25 (Excel)" },
    { file: "Ice2025.xlsx",       label: "Ice thickness 2025–26 (Excel)" },
    { file: "Pre-ice-in-2025.xlsx", label: "Pre-ice-in 2025 (Excel)" }
  ];

  function getCurrentDatasetKey() {
    const params = new URLSearchParams(window.location.search);
    const key = params.get("dataset") || "ice2025"; // default to current season
    return datasetConfigs[key] ? key : "ice2025";
  }

  // Thickness is stored as centimeters in the data source.
  function parseThicknessCm(value) {
    if (value === null || value === undefined) return null;
    const raw = String(value).trim();
    if (!raw || raw === "?" || raw.toLowerCase() === "nan") return null;

    // Accept either plain numbers ("14.2") or strings with extra text ("14 cm")
    const m = raw.match(/-?\d+(?:\.\d+)?/);
    if (!m) return null;
    const n = parseFloat(m[0]);
    return isNaN(n) ? null : n;
  }

  // Unit + language preferences (persisted)
  const UNIT_CM_PER_IN = 2.54;

  function getPreferredUnits() {
    return localStorage.getItem("ice_units") || "cm";
  }
  function setPreferredUnits(units) {
    localStorage.setItem("ice_units", units);
  }

  function cmToIn(cm) {
    return cm / UNIT_CM_PER_IN;
  }

  function formatThickness(cm, units) {
    if (cm === null || cm === undefined) return "–";
    const val = units === "in" ? cmToIn(cm) : cm;
    return val.toFixed(1);
  }

  function thicknessUnitsLabel(units) {
    return units === "in" ? "in" : "cm";
  }

  // ---- i18n (UI text) ----
  const I18N = {
    en: {
      label_units: "Units:",
      label_language: "Language:",
      dataset_label: "Dataset:",
      tab_current_season: "Current season",
      tab_selected_status: "Selected dataset status",
      tab_history: "History & all readings",
      current_season_latest: "Current season (2025–26) latest:",
      latest_selected: "Latest measurements in selected dataset:",
      safety_legend: "Safety legend:",
      safety_thin: "Thin / unsafe",
      safety_caution: "Use caution",
      safety_thicker: "Thicker",
      filter_by_lake: "Filter by lake",
      search: "Search",
      map_title: "Map – latest measurement by lake (selected dataset)",
      map_note: "Pins show the most recent reading for each lake in the selected dataset. Tap a pin for details.",
      chart_title: "Ice growth by lake",
      chart_note: "Pick a lake to see how ice thickness changed over the season (selected dataset).",
      select_lake: "Select a lake…",
      history_lake: "Lake",
      from_date: "From date",
      to_date: "To date",
      table_date: "Date",
      table_lake: "Lake",
      table_lat: "Lat",
      table_long: "Long",
      table_thickness: "Thickness",
      table_notes: "Notes",
      downloads_title: "Download ice data (Excel)",
      downloads_note: "You can download the original Excel files used to build this site.",
      tip: "Tip: right-click a file and choose “Save link as…” if your browser tries to open it instead of downloading.",
      no_current_season: "No current season readings available.",
      no_selected_dataset: "No current readings available for the selected dataset.",
      no_match_filters: "No readings match your filters."
    },
    es: {
      label_units: "Unidades:",
      label_language: "Idioma:",
      dataset_label: "Conjunto de datos:",
      tab_current_season: "Temporada actual",
      tab_selected_status: "Estado del conjunto seleccionado",
      tab_history: "Historial y lecturas",
      current_season_latest: "Última lectura (temporada 2025–26):",
      latest_selected: "Últimas lecturas del conjunto seleccionado:",
      safety_legend: "Leyenda de seguridad:",
      safety_thin: "Delgado / no seguro",
      safety_caution: "Precaución",
      safety_thicker: "Más grueso",
      filter_by_lake: "Filtrar por lago",
      search: "Buscar",
      map_title: "Mapa – última medición por lago (conjunto seleccionado)",
      map_note: "Los marcadores muestran la lectura más reciente de cada lago. Toca un marcador para ver detalles.",
      chart_title: "Crecimiento del hielo por lago",
      chart_note: "Elige un lago para ver cómo cambió el grosor del hielo (conjunto seleccionado).",
      select_lake: "Selecciona un lago…",
      history_lake: "Lago",
      from_date: "Desde",
      to_date: "Hasta",
      table_date: "Fecha",
      table_lake: "Lago",
      table_lat: "Lat",
      table_long: "Long",
      table_thickness: "Grosor",
      table_notes: "Notas",
      downloads_title: "Descargar datos (Excel)",
      downloads_note: "Puedes descargar los archivos originales de Excel usados para este sitio.",
      tip: "Consejo: haz clic derecho y elige “Guardar enlace como…” si tu navegador intenta abrirlo.",
      no_current_season: "No hay lecturas disponibles para la temporada actual.",
      no_selected_dataset: "No hay lecturas disponibles para el conjunto seleccionado.",
      no_match_filters: "No hay lecturas que coincidan con tus filtros."
    },
    fr: {
      label_units: "Unités :",
      label_language: "Langue :",
      dataset_label: "Jeu de données :",
      tab_current_season: "Saison en cours",
      tab_selected_status: "État (jeu sélectionné)",
      tab_history: "Historique et mesures",
      current_season_latest: "Dernière mesure (saison 2025–26) :",
      latest_selected: "Dernières mesures (jeu sélectionné) :",
      safety_legend: "Légende de sécurité :",
      safety_thin: "Mince / dangereux",
      safety_caution: "Prudence",
      safety_thicker: "Plus épais",
      filter_by_lake: "Filtrer par lac",
      search: "Rechercher",
      map_title: "Carte – dernière mesure par lac (jeu sélectionné)",
      map_note: "Les repères indiquent la mesure la plus récente pour chaque lac. Touchez un repère pour les détails.",
      chart_title: "Évolution de la glace par lac",
      chart_note: "Choisissez un lac pour voir l'évolution de l'épaisseur (jeu sélectionné).",
      select_lake: "Choisir un lac…",
      history_lake: "Lac",
      from_date: "Du",
      to_date: "Au",
      table_date: "Date",
      table_lake: "Lac",
      table_lat: "Lat",
      table_long: "Long",
      table_thickness: "Épaisseur",
      table_notes: "Notes",
      downloads_title: "Télécharger les données (Excel)",
      downloads_note: "Vous pouvez télécharger les fichiers Excel originaux utilisés pour ce site.",
      tip: "Astuce : clic droit puis « Enregistrer le lien sous… » si le navigateur tente d’ouvrir le fichier.",
      no_current_season: "Aucune mesure disponible pour la saison en cours.",
      no_selected_dataset: "Aucune mesure disponible pour le jeu sélectionné.",
      no_match_filters: "Aucune mesure ne correspond à vos filtres."
    },
    hmn: {
      label_units: "Chav ntsuas:",
      label_language: "Lus:",
      dataset_label: "Cov ntaub ntawv:",
      tab_current_season: "Lub caij tam sim no",
      tab_selected_status: "Xwm txheej (xaiv ntaub ntawv)",
      tab_history: "Keeb kwm & tag nrho",
      current_season_latest: "Lub caij (2025–26) tshiab tshaj:",
      latest_selected: "Ntsuas tshiab tshaj (xaiv ntaub ntawv):",
      safety_legend: "Daim ntawv qhia kev nyab xeeb:",
      safety_thin: "Nyias / tsis nyab xeeb",
      safety_caution: "Ceeb toom",
      safety_thicker: "Tuab dua",
      filter_by_lake: "Lim raws pas dej",
      search: "Nrhiav",
      map_title: "Daim ntawv qhia – ntsuas tshiab tshaj (xaiv ntaub ntawv)",
      map_note: "Cov cim qhia qhov ntsuas tshiab tshaj rau txhua pas dej. Nias rau cov ntsiab lus.",
      chart_title: "Kev loj hlob ntawm dej khov raws pas dej",
      chart_note: "Xaiv pas dej kom pom kev hloov ntawm tuab (xaiv ntaub ntawv).",
      select_lake: "Xaiv pas dej…",
      history_lake: "Pas dej",
      from_date: "Pib hnub",
      to_date: "Xaus hnub",
      table_date: "Hnub",
      table_lake: "Pas dej",
      table_lat: "Lat",
      table_long: "Long",
      table_thickness: "Tuab",
      table_notes: "Lus piav",
      downloads_title: "Rub tawm ntaub ntawv (Excel)",
      downloads_note: "Koj rub tau cov Excel qub uas siv rau lub vev xaib no.",
      tip: "Tswv yim: nyem right thiab xaiv “Save link as…” yog browser sim qhib.",
      no_current_season: "Tsis muaj ntaub ntawv rau lub caij tam sim no.",
      no_selected_dataset: "Tsis muaj ntaub ntawv rau qhov koj xaiv.",
      no_match_filters: "Tsis pom ntaub ntawv raws li koj lim."
    },
    so: {
      label_units: "Cutubyo:",
      label_language: "Luuqad:",
      dataset_label: "Xogta:",
      tab_current_season: "Xilli hadda",
      tab_selected_status: "Xaaladda xogta la doortay",
      tab_history: "Taariikh & dhammaan cabbirrada",
      current_season_latest: "Cabbirka ugu dambeeya (xilli 2025–26):",
      latest_selected: "Cabbirradii ugu dambeeyay (xogta la doortay):",
      safety_legend: "Hagaha badbaadada:",
      safety_thin: "Khafiif / halis",
      safety_caution: "Taxaddar",
      safety_thicker: "Ka sii dhumuc weyn",
      filter_by_lake: "Ku shaandhee haro",
      search: "Raadi",
      map_title: "Khariidad – cabbirka ugu dambeeya haro kasta (xogta la doortay)",
      map_note: "Calaamadaha waxay muujiyaan cabbirka ugu dambeeya ee haro kasta. Taabo si aad u aragto faahfaahin.",
      chart_title: "Kobaca barafka haro ahaan",
      chart_note: "Dooro haro si aad u aragto isbeddelka dhumucda (xogta la doortay).",
      select_lake: "Dooro haro…",
      history_lake: "Haro",
      from_date: "Laga bilaabo",
      to_date: "Ilaa",
      table_date: "Taariikh",
      table_lake: "Haro",
      table_lat: "Lat",
      table_long: "Long",
      table_thickness: "Dhumuc",
      table_notes: "Qoraal",
      downloads_title: "Soo dejiso xogta (Excel)",
      downloads_note: "Waxaad soo dejisan kartaa faylasha Excel ee asalka ah ee lagu dhisay boggan.",
      tip: "Talo: right‑click oo dooro “Save link as…” haddii browser-ku isku dayo inuu furo.",
      no_current_season: "Ma jiraan cabbirro xilli hadda ah.",
      no_selected_dataset: "Ma jiraan cabbirro xogta la doortay.",
      no_match_filters: "Ma jiraan cabbirro ku habboon shaandhaynta."
    },
    ar: {
      label_units: "الوحدات:",
      label_language: "اللغة:",
      dataset_label: "مجموعة البيانات:",
      tab_current_season: "الموسم الحالي",
      tab_selected_status: "حالة المجموعة المختارة",
      tab_history: "السجل وجميع القياسات",
      current_season_latest: "آخر قياس (موسم 2025–26):",
      latest_selected: "آخر قياسات المجموعة المختارة:",
      safety_legend: "دليل السلامة:",
      safety_thin: "رقيق / غير آمن",
      safety_caution: "استخدم الحذر",
      safety_thicker: "أكثر سماكة",
      filter_by_lake: "تصفية حسب البحيرة",
      search: "بحث",
      map_title: "الخريطة – آخر قياس لكل بحيرة (المجموعة المختارة)",
      map_note: "تُظهر العلامات أحدث قراءة لكل بحيرة. اضغط على العلامة للتفاصيل.",
      chart_title: "تغيّر سماكة الجليد حسب البحيرة",
      chart_note: "اختر بحيرة لرؤية تغير السماكة خلال الموسم (المجموعة المختارة).",
      select_lake: "اختر بحيرة…",
      history_lake: "البحيرة",
      from_date: "من تاريخ",
      to_date: "إلى تاريخ",
      table_date: "التاريخ",
      table_lake: "البحيرة",
      table_lat: "خط العرض",
      table_long: "خط الطول",
      table_thickness: "السماكة",
      table_notes: "ملاحظات",
      downloads_title: "تنزيل البيانات (Excel)",
      downloads_note: "يمكنك تنزيل ملفات Excel الأصلية المستخدمة لبناء هذا الموقع.",
      tip: "نصيحة: انقر بزر الفأرة الأيمن واختر “Save link as…” إذا حاول المتصفح فتح الملف.",
      no_current_season: "لا توجد قراءات للموسم الحالي.",
      no_selected_dataset: "لا توجد قراءات للمجموعة المختارة.",
      no_match_filters: "لا توجد قراءات مطابقة للفلاتر."
    },
    arc: {
      label_units: "Units:",
      label_language: "Language:",
      dataset_label: "Dataset:",
      tab_current_season: "Current season",
      tab_selected_status: "Selected dataset status",
      tab_history: "History & all readings",
      current_season_latest: "Current season (2025–26) latest:",
      latest_selected: "Latest measurements in selected dataset:",
      safety_legend: "Safety legend:",
      safety_thin: "Thin / unsafe",
      safety_caution: "Use caution",
      safety_thicker: "Thicker",
      filter_by_lake: "Filter by lake",
      search: "Search",
      map_title: "Map – latest measurement by lake (selected dataset)",
      map_note: "Pins show the most recent reading for each lake in the selected dataset. Tap a pin for details.",
      chart_title: "Ice growth by lake",
      chart_note: "Pick a lake to see how ice thickness changed over the season (selected dataset).",
      select_lake: "Select a lake…",
      history_lake: "Lake",
      from_date: "From date",
      to_date: "To date",
      table_date: "Date",
      table_lake: "Lake",
      table_lat: "Lat",
      table_long: "Long",
      table_thickness: "Thickness",
      table_notes: "Notes",
      downloads_title: "Download ice data (Excel)",
      downloads_note: "You can download the original Excel files used to build this site.",
      tip: "Tip: right-click a file and choose “Save link as…” if your browser tries to open it instead of downloading.",
      no_current_season: "No current season readings available.",
      no_selected_dataset: "No current readings available for the selected dataset.",
      no_match_filters: "No readings match your filters."
    }
  };

  function getPreferredLanguage() {
    return localStorage.getItem("ice_lang") || "en";
  }
  function setPreferredLanguage(lang) {
    localStorage.setItem("ice_lang", lang);
  }

  function t(key) {
    const lang = state.lang || "en";
    return (I18N[lang] && I18N[lang][key]) || I18N.en[key] || key;
  }

  function applyLanguage(lang) {
    state.lang = lang;
    document.documentElement.dir = (lang === "ar") ? "rtl" : "ltr";

    const datasetLabel = document.querySelector('label[for="dataset-select"]');
    if (datasetLabel) datasetLabel.textContent = t("dataset_label");

    const unitLabel = document.querySelector('label[for="unit-select"]');
    if (unitLabel) unitLabel.textContent = t("label_units");

    const langLabel = document.querySelector('label[for="lang-select"]');
    if (langLabel) langLabel.textContent = t("label_language");

    document.querySelectorAll(".tab-button").forEach(btn => {
      const tab = btn.dataset.tab;
      if (tab === "currentSeason") btn.textContent = t("tab_current_season");
      if (tab === "current") btn.textContent = t("tab_selected_status");
      if (tab === "history") btn.textContent = t("tab_history");
    });

    const mapTitle = document.querySelector(".map-card h2");
    if (mapTitle) mapTitle.textContent = t("map_title");
    const mapNote = document.querySelector(".map-card .map-note");
    if (mapNote) mapNote.textContent = t("map_note");

    const chartTitle = document.querySelector(".chart-card h2");
    if (chartTitle) chartTitle.textContent = t("chart_title");
    const chartNote = document.querySelector(".chart-card p");
    if (chartNote) chartNote.textContent = t("chart_note");
    const lakeOpt = document.querySelector("#chart-lake-select option[value='']");
    if (lakeOpt) lakeOpt.textContent = t("select_lake");

    const f1 = document.querySelector('label[for="current-lake-filter"]');
    if (f1) f1.textContent = t("filter_by_lake");
    const f2 = document.querySelector('label[for="search-filter"]');
    if (f2) f2.textContent = t("search");
    const f3 = document.querySelector('label[for="history-lake-filter"]');
    if (f3) f3.textContent = t("history_lake");
    const f4 = document.querySelector('label[for="history-date-from"]');
    if (f4) f4.textContent = t("from_date");
    const f5 = document.querySelector('label[for="history-date-to"]');
    if (f5) f5.textContent = t("to_date");

    const ths = document.querySelectorAll("thead th");
    if (ths.length >= 6) {
      ths[0].textContent = t("table_date");
      ths[1].textContent = t("table_lake");
      ths[2].textContent = t("table_lat");
      ths[3].textContent = t("table_long");
      ths[4].textContent = t("table_thickness");
      ths[5].textContent = t("table_notes");
    }

    const dlTitle = document.querySelector(".download-card h2");
    if (dlTitle) dlTitle.textContent = t("downloads_title");
    const dlP = document.querySelector(".download-card p");
    if (dlP) dlP.textContent = t("downloads_note");
    const dlTip = document.querySelector(".download-note");
    if (dlTip) dlTip.textContent = t("tip");

    // Re-render to update unit strings
    renderCurrentSeason();
    renderCurrent();
    renderHistory();
    updateMapMarkers();
    updateChartForSelectedLake();
  }




  function formatDate(dateStr) {
    if (!dateStr) return "";
    const d = new Date(dateStr);
    if (isNaN(d.getTime())) return dateStr;
    return d.toLocaleDateString(undefined, { year: "numeric", month: "short", day: "numeric" });
  }

  function safetyCategory(thicknessCm) {
    const inches = thicknessCm === null ? null : cmToIn(thicknessCm);
    if (inches === null) return { label: "Unknown", className: "", dotClass: "" };
    if (inches < 4) return { label: t("safety_thin"), className: "unsafe", dotClass: "danger" };
    if (inches < 8) return { label: t("safety_caution"), className: "caution", dotClass: "warn" };
    return { label: t("safety_thicker") + " (" + t("safety_caution") + ")", className: "safe", dotClass: "safe" };
  }

  const state = {
    data: [],
    latestDate: null,
    latestRows: [],
    currentDatasetKey: null,
    map: null,
    mapLayer: null,
    chart: null,
    // Current season (always Ice2025)
    currentSeasonData: [],
    currentSeasonLatestDate: null,
    currentSeasonLatestRows: [],
    units: getPreferredUnits(),
    lang: getPreferredLanguage()
  };

  async function loadData() {
  const datasetKey = getCurrentDatasetKey();
  const cfg = datasetConfigs[datasetKey];
  state.currentDatasetKey = datasetKey;

  const json = await fetchDataset(cfg);

  const processed = json
    .map(row => {
      const cm = parseFloat(String(row.thickness_cm).trim());
      return { ...row, thickness_cm_value: isNaN(cm) ? null : cm };
    })
    .filter(row => row.date);

  state.data = processed;

  const dates = processed
    .map(r => new Date(r.date))
    .filter(d => !isNaN(d.getTime()));
  const maxDate = dates.length ? new Date(Math.max(...dates)) : null;
  state.latestDate = maxDate;

  state.latestRows = maxDate
    ? processed.filter(r => new Date(r.date).toDateString() === maxDate.toDateString())
    : [];

  await loadCurrentSeasonData();

  initFilters(processed);
  initMap();
  initChart();
  renderCurrentSeason();
  renderCurrent();
  renderHistory();
  updateMapMarkers();
  updateChartForSelectedLake();
}

  async function loadCurrentSeasonData() {
  const cfg = datasetConfigs.ice2025;
  try {
    const json = await fetchDataset(cfg);

    const processed = json
      .map(row => {
        const cm = parseFloat(String(row.thickness_cm).trim());
        return { ...row, thickness_cm_value: isNaN(cm) ? null : cm };
      })
      .filter(row => row.date);

    state.currentSeasonData = processed;

    const dates = processed
      .map(r => new Date(r.date))
      .filter(d => !isNaN(d.getTime()));
    const maxDate = dates.length ? new Date(Math.max(...dates)) : null;
    state.currentSeasonLatestDate = maxDate;

    state.currentSeasonLatestRows = maxDate
      ? processed.filter(r => new Date(r.date).toDateString() === maxDate.toDateString())
      : [];
  } catch (e) {
    console.error("Failed to load current season data", e);
    state.currentSeasonData = [];
    state.currentSeasonLatestDate = null;
    state.currentSeasonLatestRows = [];
  }
}
  }

  function initFilters(data) {
    const lakes = Array.from(new Set(data.map(r => r.lake))).sort((a, b) =>
      String(a).localeCompare(String(b))
    );

    const currentLakeSelect = document.getElementById("current-lake-filter");
    const historyLakeSelect = document.getElementById("history-lake-filter");
    const chartLakeSelect = document.getElementById("chart-lake-select");

    currentLakeSelect.innerHTML = '<option value="all">All lakes</option>';
    historyLakeSelect.innerHTML = '<option value="all">All lakes</option>';
    chartLakeSelect.innerHTML = '<option value="">Select a lake…</option>';

    for (const lake of lakes) {
      const opt1 = document.createElement("option");
      opt1.value = lake;
      opt1.textContent = lake;
      currentLakeSelect.appendChild(opt1);

      const opt2 = document.createElement("option");
      opt2.value = lake;
      opt2.textContent = lake;
      historyLakeSelect.appendChild(opt2);

      const opt3 = document.createElement("option");
      opt3.value = lake;
      opt3.textContent = lake;
      chartLakeSelect.appendChild(opt3);
    }

    if (lakes.length && !chartLakeSelect.value) {
      chartLakeSelect.value = lakes[0];
    }

    const validDates = data
      .map(r => new Date(r.date))
      .filter(d => !isNaN(d.getTime()))
      .sort((a, b) => a - b);

    if (validDates.length) {
      const min = validDates[0];
      const max = validDates[validDates.length - 1];
      const fromInput = document.getElementById("history-date-from");
      const toInput = document.getElementById("history-date-to");
      fromInput.value = min.toISOString().slice(0, 10);
      toInput.value = max.toISOString().slice(0, 10);
    }

    currentLakeSelect.addEventListener("change", () => {
      renderCurrent();
      updateMapMarkers();
    });
    document.getElementById("search-filter").addEventListener("input", renderCurrent);

    historyLakeSelect.addEventListener("change", renderHistory);
    document.getElementById("history-date-from").addEventListener("change", renderHistory);
    document.getElementById("history-date-to").addEventListener("change", renderHistory);

    chartLakeSelect.addEventListener("change", updateChartForSelectedLake);
  }

  function renderCurrentSeason() {
    const grid = document.getElementById("current-season-grid");
    grid.innerHTML = "";

    const latestLabel = document.getElementById("season-latest-date-label");
    const statusDot = document.getElementById("season-latest-status-dot");

    if (!state.currentSeasonLatestDate || !state.currentSeasonLatestRows.length) {
      latestLabel.textContent = "No data";
      statusDot.className = "status-dot";
      grid.innerHTML = "<p>No current season readings available.</p>";
      return;
    }

    latestLabel.textContent = formatDate(state.currentSeasonLatestDate.toISOString());

    const maxRisk = state.currentSeasonLatestRows.reduce((acc, r) => {
      if (r.thickness_cm_num === null) return acc;
      if (cmToIn(r.thickness_cm_num) < 4) return 3;
      if (cmToIn(r.thickness_cm_num) < 8) return Math.max(acc, 2);
      return Math.max(acc, 1);
    }, 0);

    statusDot.className = "status-dot " + (maxRisk === 3 ? "danger" : maxRisk === 2 ? "warn" : "safe");

    // Group latest rows by lake
    const grouped = new Map();
    for (const r of state.currentSeasonLatestRows) {
      if (!grouped.has(r.lake)) grouped.set(r.lake, []);
      grouped.get(r.lake).push(r);
    }

    const sortedLakes = Array.from(grouped.keys()).sort((a, b) => String(a).localeCompare(String(b)));

    for (const lake of sortedLakes) {
      const group = grouped.get(lake);
      const best = group.reduce((a, b) => {
        const thA = a.thickness_cm_num ?? -Infinity;
        const thB = b.thickness_cm_num ?? -Infinity;
        return thB > thA ? b : a;
      }, group[0]);

      const card = document.createElement("article");
      card.className = "lake-card";

      const header = document.createElement("div");
      header.className = "lake-header";

      const lakeName = document.createElement("div");
      lakeName.className = "lake-name";
      lakeName.textContent = lake;

      const dateSpan = document.createElement("div");
      dateSpan.className = "lake-date";
      dateSpan.textContent = formatDate(best.date);

      header.appendChild(lakeName);
      header.appendChild(dateSpan);

      const thicknessDiv = document.createElement("div");
      thicknessDiv.className = "thickness";

      const units = state.units || "cm";
      const thicknessValue = best.thickness_cm_num;
      thicknessDiv.textContent = thicknessValue === null ? "–" : formatThickness(thicknessValue, units);
      const unitSpan = document.createElement("span");
      unitSpan.className = "unit";
      unitSpan.textContent = thicknessValue === null ? "" : thicknessUnitsLabel(units);
      thicknessDiv.appendChild(unitSpan);

      const safetyInfo = safetyCategory(best.thickness_cm_num);
      const safety = document.createElement("span");
      safety.className = "safety-tag " + safetyInfo.className;
      safety.textContent = safetyInfo.label;

      const meta = document.createElement("div");
      meta.className = "lake-meta";
      if (best.lat || best.long) {
        meta.textContent = [best.lat, best.long].filter(Boolean).join(" · ");
      }

      const desc = document.createElement("div");
      desc.className = "description";
      desc.textContent = best.description || "";

      card.appendChild(header);
      card.appendChild(thicknessDiv);
      card.appendChild(safety);
      if (meta.textContent) card.appendChild(meta);
      if (desc.textContent) card.appendChild(desc);

      grid.appendChild(card);
    }

    if (!grid.children.length) {
      grid.innerHTML = "<p>No readings for the current season.</p>";
    }
  }

  function renderCurrent() {
    const grid = document.getElementById("current-grid");
    grid.innerHTML = "";

    const lakeFilter = document.getElementById("current-lake-filter").value;
    const search = document.getElementById("search-filter").value.toLowerCase().trim();

    const latestDateLabel = document.getElementById("latest-date-label");
    const latestStatusDot = document.getElementById("latest-status-dot");

    if (!state.latestDate || !state.latestRows.length) {
      latestDateLabel.textContent = "No data";
      latestStatusDot.className = "status-dot";
      grid.innerHTML = "<p>No current readings available for the selected dataset.</p>";
      return;
    }

    latestDateLabel.textContent = formatDate(state.latestDate.toISOString());

    const maxRisk = state.latestRows.reduce((acc, r) => {
      if (r.thickness_cm_num === null) return acc;
      if (cmToIn(r.thickness_cm_num) < 4) return 3;
      if (cmToIn(r.thickness_cm_num) < 8) return Math.max(acc, 2);
      return Math.max(acc, 1);
    }, 0);

    latestStatusDot.className = "status-dot " + (maxRisk === 3 ? "danger" : maxRisk === 2 ? "warn" : "safe");

    let rows = state.latestRows;

    if (lakeFilter !== "all") {
      rows = rows.filter(r => r.lake === lakeFilter);
    }

    if (search) {
      rows = rows.filter(r => {
        const hay = (r.lake + " " + (r.description || "")).toLowerCase();
        return hay.includes(search);
      });
    }

    const grouped = new Map();
    for (const r of rows) {
      if (!grouped.has(r.lake)) grouped.set(r.lake, []);
      grouped.get(r.lake).push(r);
    }

    const sortedLakes = Array.from(grouped.keys()).sort((a, b) => String(a).localeCompare(String(b)));

    for (const lake of sortedLakes) {
      const group = grouped.get(lake);
      const best = group.reduce((a, b) => {
        const thA = a.thickness_cm_num ?? -Infinity;
        const thB = b.thickness_cm_num ?? -Infinity;
        return thB > thA ? b : a;
      }, group[0]);

      const card = document.createElement("article");
      card.className = "lake-card";

      const header = document.createElement("div");
      header.className = "lake-header";

      const lakeName = document.createElement("div");
      lakeName.className = "lake-name";
      lakeName.textContent = lake;

      const dateSpan = document.createElement("div");
      dateSpan.className = "lake-date";
      dateSpan.textContent = formatDate(best.date);

      header.appendChild(lakeName);
      header.appendChild(dateSpan);

      const thicknessDiv = document.createElement("div");
      thicknessDiv.className = "thickness";

      const units = state.units || "cm";
      const thicknessValue = best.thickness_cm_num;
      thicknessDiv.textContent = thicknessValue === null ? "–" : formatThickness(thicknessValue, units);
      const unitSpan = document.createElement("span");
      unitSpan.className = "unit";
      unitSpan.textContent = thicknessValue === null ? "" : thicknessUnitsLabel(units);
      thicknessDiv.appendChild(unitSpan);

      const safetyInfo = safetyCategory(best.thickness_cm_num);
      const safety = document.createElement("span");
      safety.className = "safety-tag " + safetyInfo.className;
      safety.textContent = safetyInfo.label;

      const meta = document.createElement("div");
      meta.className = "lake-meta";
      if (best.lat || best.long) {
        meta.textContent = [best.lat, best.long].filter(Boolean).join(" · ");
      }

      const desc = document.createElement("div");
      desc.className = "description";
      desc.textContent = best.description || "";

      card.appendChild(header);
      card.appendChild(thicknessDiv);
      card.appendChild(safety);
      if (meta.textContent) card.appendChild(meta);
      if (desc.textContent) card.appendChild(desc);

      grid.appendChild(card);
    }

    if (!grid.children.length) {
      grid.innerHTML = "<p>No readings match your filters.</p>";
    }
  }

  let historySort = { key: "date", dir: "asc" };

  function renderHistory() {
    const tbody = document.getElementById("history-tbody");
    tbody.innerHTML = "";

    const lakeFilter = document.getElementById("history-lake-filter").value;
    const fromStr = document.getElementById("history-date-from").value;
    const toStr = document.getElementById("history-date-to").value;

    const from = fromStr ? new Date(fromStr) : null;
    const to = toStr ? new Date(toStr) : null;
    if (to) {
      to.setHours(23, 59, 59, 999);
    }

    let rows = state.data.slice();

    if (lakeFilter !== "all") {
      rows = rows.filter(r => r.lake === lakeFilter);
    }

    if (from) {
      rows = rows.filter(r => {
        const d = new Date(r.date);
        return !isNaN(d.getTime()) && d >= from;
      });
    }

    if (to) {
      rows = rows.filter(r => {
        const d = new Date(r.date);
        return !isNaN(d.getTime()) && d <= to;
      });
    }

    const key = historySort.key;
    const dir = historySort.dir === "asc" ? 1 : -1;

    rows.sort((a, b) => {
      const va = a[key];
      const vb = b[key];
      if (key === "date") {
        const da = new Date(va);
        const db = new Date(vb);
        return (da - db) * dir;
      }
      if (key === "thickness_cm") {
        const ta = a.thickness_cm_num ?? -Infinity;
        const tb = b.thickness_cm_num ?? -Infinity;
        return (ta - tb) * dir;
      }
      return String(va).localeCompare(String(vb)) * dir;
    });

    for (const r of rows) {
      const tr = document.createElement("tr");

      const tdDate = document.createElement("td");
      tdDate.textContent = formatDate(r.date);
      tr.appendChild(tdDate);

      const tdLake = document.createElement("td");
      tdLake.textContent = r.lake;
      tr.appendChild(tdLake);

      const tdLat = document.createElement("td");
      tdLat.textContent = r.lat || "";
      tr.appendChild(tdLat);

      const tdLong = document.createElement("td");
      tdLong.textContent = r.long || "";
      tr.appendChild(tdLong);

      const tdThick = document.createElement("td");
      const units = state.units || "cm";
      tdThick.textContent = r.thickness_cm_num === null ? "" : (formatThickness(r.thickness_cm_num, units) + " " + thicknessUnitsLabel(units));
      tr.appendChild(tdThick);

      const tdDesc = document.createElement("td");
      tdDesc.textContent = r.description || "";
      tr.appendChild(tdDesc);

      tbody.appendChild(tr);
    }

    if (!tbody.children.length) {
      const tr = document.createElement("tr");
      const td = document.createElement("td");
      td.colSpan = 6;
      td.textContent = "No readings match your filters.";
      tr.appendChild(td);
      tbody.appendChild(tr);
    }
  }

  function initTabs() {
    const buttons = document.querySelectorAll(".tab-button");
    const panels = document.querySelectorAll(".tab-panel");

    buttons.forEach(btn => {
      btn.addEventListener("click", () => {
        const tab = btn.dataset.tab;
        buttons.forEach(b => b.classList.toggle("active", b === btn));
        panels.forEach(p => {
          p.hidden = p.id !== tab;
        });
        if (tab === "current" && state.map) {
          setTimeout(() => state.map.invalidateSize(), 0);
        }
      });
    });
  }

  function initHistorySorting() {
    const headers = document.querySelectorAll("thead th[data-sort]");
    headers.forEach(th => {
      th.addEventListener("click", () => {
        const key = th.dataset.sort;
        if (historySort.key === key) {
          historySort.dir = historySort.dir === "asc" ? "desc" : "asc";
        } else {
          historySort.key = key;
          historySort.dir = "asc";
        }
        renderHistory();
      });
    });
  }

  function initMap() {
    if (state.map) return;
    const mapEl = document.getElementById("map");
    if (!mapEl) return;

    state.map = L.map(mapEl).setView([44.96, -93.29], 12);

    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 18,
      attribution: "&copy; OpenStreetMap contributors"
    }).addTo(state.map);

    state.mapLayer = L.layerGroup().addTo(state.map);
  }

  function updateMapMarkers() {
    if (!state.map || !state.mapLayer) return;

    state.mapLayer.clearLayers();

    const lakeFilter = document.getElementById("current-lake-filter").value;

    let rows = state.latestRows.slice();
    if (lakeFilter !== "all") {
      rows = rows.filter(r => r.lake === lakeFilter);
    }

    const grouped = new Map();
    for (const r of rows) {
      if (!grouped.has(r.lake)) grouped.set(r.lake, []);
      grouped.get(r.lake).push(r);
    }

    const markers = [];

    grouped.forEach((group, lake) => {
      const best = group.reduce((a, b) => {
        const thA = a.thickness_cm_num ?? -Infinity;
        const thB = b.thickness_cm_num ?? -Infinity;
        return thB > thA ? b : a;
      }, group[0]);

      const lat = parseFloat(best.lat);
      const lng = parseFloat(best.long);
      if (isNaN(lat) || isNaN(lng)) return;

      const safety = safetyCategory(best.thickness_cm_num);
      let color = "#4cd964";
      if (safety.className === "caution") color = "#ffc857";
      if (safety.className === "unsafe") color = "#ff4f6a";

      const marker = L.circleMarker([lat, lng], {
        radius: 7,
        weight: 2,
        color: color,
        fillColor: color,
        fillOpacity: 0.7
      }).addTo(state.mapLayer);

      marker.bindPopup(
        `<strong>${lake}</strong><br>` +
        `${formatDate(best.date)}<br>` +
        (() => { const units = state.units || "cm"; const v = best.thickness_cm_num; return `Thickness: ${v===null ? "–" : formatThickness(v, units)} ${v===null ? "" : thicknessUnitsLabel(units)}<br>`; })() +
        `<small>${safety.label}</small>`
      );

      markers.push(marker);
    });

    if (markers.length) {
      const group = L.featureGroup(markers);
      state.map.fitBounds(group.getBounds().pad(0.2));
    }
  }

  function initChart() {
    const ctx = document.getElementById("lake-chart");
    if (!ctx) return;
    if (state.chart) {
      state.chart.destroy();
    }

    state.chart = new Chart(ctx, {
      type: "line",
      data: {
        labels: [],
        datasets: [
          {
            label: "Ice thickness",
            data: [],
            tension: 0.25,
            pointRadius: 3,
            pointHoverRadius: 4,
            borderWidth: 2
          }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          x: {
            ticks: {
              autoSkip: true,
              maxTicksLimit: 8
            }
          },
          y: {
            title: {
              display: true,
              text: (state.units === "in" ? "Thickness (in)" : "Thickness (cm)")
            },
            beginAtZero: true
          }
        },
        plugins: {
          legend: { display: false },
          tooltip: {
            callbacks: {
              label: function(context) {
                const value = context.parsed.y;
                const units = state.units || "cm";
                return ` ${value.toFixed(2)} ${units}`;
              }
            }
          }
        }
      }
    });
  }

  function updateChartForSelectedLake() {
    if (!state.chart) return;

    const lakeSelect = document.getElementById("chart-lake-select");
    const lake = lakeSelect.value;
    const chart = state.chart;

    if (!lake) {
      chart.data.labels = [];
      chart.data.datasets[0].data = [];
      chart.update();
      return;
    }

    const rows = state.data
      .filter(r => r.lake === lake && r.thickness_cm_num !== null)
      .sort((a, b) => new Date(a.date) - new Date(b.date));

    const labels = rows.map(r => formatDate(r.date));
    const units = state.units || "cm";
    const values = rows.map(r => units === "in" ? cmToIn(r.thickness_cm_num) : r.thickness_cm_num);

    chart.data.labels = labels;
    chart.data.datasets[0].data = values;
    chart.options.scales.y.title.text = (units === "in" ? "Thickness (in)" : "Thickness (cm)");
    chart.update();
  }

  function renderExcelDownloads() {
    const listEl = document.getElementById("excel-download-list");
    if (!listEl) return;

    listEl.innerHTML = "";

    if (!excelFiles.length) {
      const li = document.createElement("li");
      li.textContent = "No Excel files are currently available.";
      listEl.appendChild(li);
      return;
    }

    excelFiles.forEach(item => {
      const li = document.createElement("li");
      const a = document.createElement("a");
      a.href = item.file;
      a.download = "";
      a.textContent = item.label || item.file;
      li.appendChild(a);
      listEl.appendChild(li);
    });
  }

  document.addEventListener("DOMContentLoaded", () => {
    initTabs();
    initHistorySorting();
    renderExcelDownloads();


    // Units select
    const unitSelectEl = document.getElementById("unit-select");
    if (unitSelectEl) {
      unitSelectEl.value = state.units;
      unitSelectEl.addEventListener("change", () => {
        state.units = unitSelectEl.value;
        setPreferredUnits(state.units);
        renderCurrentSeason();
        renderCurrent();
        renderHistory();
        updateMapMarkers();
        updateChartForSelectedLake();
      });
    }

    // Language select
    const langSelectEl = document.getElementById("lang-select");
    if (langSelectEl) {
      langSelectEl.value = state.lang;
      langSelectEl.addEventListener("change", () => {
        state.lang = langSelectEl.value;
        setPreferredLanguage(state.lang);
        applyLanguage(state.lang);
      });
    }

    // Apply language at startup
    applyLanguage(state.lang);

    // Set dataset select to URL param
    const datasetSelectEl = document.getElementById("dataset-select");
    if (datasetSelectEl) {
      const currentKey = getCurrentDatasetKey();
      datasetSelectEl.value = currentKey;

      datasetSelectEl.addEventListener("change", () => {
        const key = datasetSelectEl.value;
        const params = new URLSearchParams(window.location.search);
        params.set("dataset", key);
        window.location.search = params.toString();
      });
    }

    loadData().catch(err => {
      console.error("Failed to load data:", err);
      const grid = document.getElementById("current-grid");
      if (grid) {
        grid.innerHTML = "<p>Could not load data JSON. Make sure the JSON files are in the same folder as index.html.</p>";
      }
    });
  });
</script>
</body>
</html>