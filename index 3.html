<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Minneapolis Chain of Lakes – Ice Report</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Leaflet (map) -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />

  <style>
    :root {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #0b1720;
      color: #f2f6fb;
      --accent: #33c3ff;
      --accent-soft: rgba(51, 195, 255, 0.12);
      --card-bg: rgba(9, 23, 36, 0.95);
      --border-subtle: rgba(255, 255, 255, 0.06);
      --danger: #ff4f6a;
      --warn: #ffc857;
      --safe: #4cd964;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
    }

    header {
      padding: 1.5rem 1.5rem 0.75rem;
      border-bottom: 1px solid var(--border-subtle);
      background: radial-gradient(circle at top, #102b3f 0, #050b11 60%);
    }

    .title {
      display: flex;
      flex-wrap: wrap;
      align-items: baseline;
      gap: 0.5rem;
    }

    .title h1 {
      margin: 0;
      font-size: clamp(1.5rem, 2vw + 1rem, 2.2rem);
      letter-spacing: 0.02em;
    }

    .title span.badge {
      font-size: 0.8rem;
      padding: 0.15rem 0.6rem;
      border-radius: 999px;
      border: 1px solid var(--accent);
      background: var(--accent-soft);
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }

    header p {
      margin: 0.5rem 0 0;
      max-width: 40rem;
      color: rgba(255,255,255,0.8);
      font-size: 0.95rem;
    }

    .dataset-switcher {
      margin-top: 0.75rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      align-items: center;
      font-size: 0.85rem;
    }

    .dataset-switcher label {
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: rgba(255,255,255,0.7);
      font-size: 0.75rem;
    }

    .dataset-switcher select {
      border-radius: 999px;
      border: 1px solid var(--border-subtle);
      padding: 0.2rem 0.75rem;
      background: rgba(4,12,20,0.9);
      color: #f9fbff;
      font-size: 0.85rem;
    }

    main {
      flex: 1;
      padding: 1.5rem;
      max-width: 1200px;
      width: 100%;
      margin: 0 auto;
    }

    .tabs {
      margin-bottom: 1rem;
      display: inline-flex;
      border-radius: 999px;
      background: rgba(0,0,0,0.4);
      border: 1px solid var(--border-subtle);
      padding: 0.2rem;
    }

    .tab-button {
      border: none;
      background: transparent;
      color: rgba(255,255,255,0.75);
      padding: 0.4rem 1rem;
      border-radius: 999px;
      font-size: 0.9rem;
      cursor: pointer;
      transition: background 0.15s, color 0.15s;
      white-space: nowrap;
    }

    .tab-button.active {
      background: var(--accent);
      color: #021018;
    }

    .status-bar {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      align-items: center;
      margin: 1rem 0 1.5rem;
    }

    .status-pill {
      padding: 0.4rem 0.75rem;
      border-radius: 999px;
      font-size: 0.8rem;
      border: 1px solid var(--border-subtle);
      background: rgba(0,0,0,0.35);
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
    }

    .status-pill strong {
      font-weight: 600;
    }

    .status-dot {
      width: 0.55rem;
      height: 0.55rem;
      border-radius: 50%;
      background: var(--safe);
    }

    .status-dot.warn { background: var(--warn); }
    .status-dot.danger { background: var(--danger); }

    .filters {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      align-items: center;
      margin-bottom: 1.25rem;
    }

    .filters label {
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: rgba(255,255,255,0.7);
    }

    .filters select,
    .filters input[type="date"],
    .filters input[type="search"] {
      border-radius: 999px;
      border: 1px solid var(--border-subtle);
      padding: 0.35rem 0.8rem;
      background: rgba(4,12,20,0.9);
      color: #f9fbff;
      font-size: 0.85rem;
      min-width: 8rem;
    }

    .filters-group {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .summary-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
      gap: 0.75rem;
      margin-bottom: 1.5rem;
    }

    .lake-card {
      border-radius: 1rem;
      border: 1px solid var(--border-subtle);
      padding: 0.75rem 0.85rem;
      background: var(--card-bg);
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
    }

    .lake-header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 0.5rem;
    }

    .lake-name {
      font-weight: 600;
      font-size: 0.95rem;
    }

    .lake-date {
      font-size: 0.75rem;
      color: rgba(255,255,255,0.6);
    }

    .thickness {
      font-size: 1.2rem;
    }

    .thickness span.unit {
      font-size: 0.75rem;
      color: rgba(255,255,255,0.7);
      margin-left: 0.2rem;
    }

    .safety-tag {
      font-size: 0.75rem;
      padding: 0.1rem 0.55rem;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(0,0,0,0.3);
    }

    .safety-tag.safe {
      border-color: var(--safe);
      color: var(--safe);
    }
    .safety-tag.caution {
      border-color: var(--warn);
      color: var(--warn);
    }
    .safety-tag.unsafe {
      border-color: var(--danger);
      color: var(--danger);
    }

    .lake-meta {
      font-size: 0.75rem;
      color: rgba(255,255,255,0.7);
    }

    .description {
      font-size: 0.8rem;
      color: rgba(255,255,255,0.8);
      margin-top: 0.25rem;
      white-space: pre-line;
    }

    .table-wrapper {
      border-radius: 1rem;
      border: 1px solid var(--border-subtle);
      background: var(--card-bg);
      overflow: hidden;
      margin-top: 1.25rem;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.85rem;
    }

    thead {
      background: rgba(5,15,25,0.95);
    }

    thead th {
      padding: 0.6rem 0.75rem;
      text-align: left;
      border-bottom: 1px solid var(--border-subtle);
      text-transform: uppercase;
      letter-spacing: 0.08em;
      font-size: 0.7rem;
      color: rgba(255,255,255,0.7);
      cursor: pointer;
      user-select: none;
    }

    tbody tr:nth-child(even) {
      background: rgba(0,0,0,0.35);
    }

    tbody td {
      padding: 0.55rem 0.75rem;
      border-bottom: 1px solid rgba(255,255,255,0.04);
    }

    .table-scroll {
      max-height: 420px;
      overflow: auto;
    }

    .map-card,
    .chart-card,
    .download-card {
      border-radius: 1rem;
      border: 1px solid var(--border-subtle);
      background: var(--card-bg);
      padding: 0.9rem 0.95rem 1rem;
      margin-bottom: 1.5rem;
    }

    .map-card h2,
    .chart-card h2,
    .download-card h2 {
      margin: 0 0 0.25rem;
      font-size: 1rem;
    }

    .map-note,
    .chart-card p,
    .download-card p {
      margin: 0.15rem 0 0.5rem;
      font-size: 0.8rem;
      color: rgba(255,255,255,0.75);
    }

    .map-container {
      width: 100%;
      height: 260px;
      border-radius: 0.75rem;
      overflow: hidden;
      margin-top: 0.4rem;
    }

    .chart-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.75rem;
      margin-bottom: 0.5rem;
    }

    .chart-header-text {
      flex: 1;
    }

    #chart-lake-select {
      border-radius: 999px;
      border: 1px solid var(--border-subtle);
      padding: 0.35rem 0.8rem;
      background: rgba(4,12,20,0.9);
      color: #f9fbff;
      font-size: 0.85rem;
    }

    .download-card ul {
      list-style: none;
      padding-left: 0;
      margin: 0 0 0.4rem;
      font-size: 0.85rem;
    }

    .download-card li + li {
      margin-top: 0.25rem;
    }

    .download-card a {
      color: var(--accent);
      text-decoration: none;
    }

    .download-card a:hover {
      text-decoration: underline;
    }

    .download-note {
      font-size: 0.75rem;
      color: rgba(255,255,255,0.6);
    }

    footer {
      padding: 0.9rem 1.5rem 1.1rem;
      border-top: 1px solid var(--border-subtle);
      font-size: 0.75rem;
      color: rgba(255,255,255,0.7);
      background: #050b11;
    }

    footer a {
      color: var(--accent);
      text-decoration: none;
    }

    footer a:hover {
      text-decoration: underline;
    }

    @media (max-width: 640px) {
      header {
        padding: 1rem;
      }
      main {
        padding: 1rem;
      }
      .filters {
        flex-direction: column;
        align-items: stretch;
      }
      .status-bar {
        flex-direction: column;
        align-items: flex-start;
      }
      .chart-header {
        flex-direction: column;
        align-items: flex-start;
      }
      #chart-lake-select {
        width: 100%;
      }
    }
  </style>
</head>
<body>
<header>
  <div class="title">
    <h1>Minneapolis Chain of Lakes – Ice Report</h1>
    <span class="badge">Multi-season</span>
  </div>
  <p>
    Weekly ice thickness measurements around the Chain of Lakes. This page shows the
    latest readings and lets you explore historical data by lake and date. Always
    double-check conditions in person before going on the ice.
  </p>

  <div class="dataset-switcher">
    <label for="dataset-select">Dataset:</label>
    <select id="dataset-select">
      <option value="ice2025">Main season 2025–26</option>
      <option value="ice2024">Main season 2024–25</option>
      <option value="preice2025">Pre-ice-in 2025</option>
    </select>
  </div>
</header>

<main>
  <div class="tabs" role="tablist">
    <button class="tab-button active" data-tab="currentSeason" type="button">Current season</button>
    <button class="tab-button" data-tab="current" type="button">Selected dataset status</button>
    <button class="tab-button" data-tab="history" type="button">History &amp; all readings</button>
  </div>

  <!-- Current season (always Ice2025) -->
  <section id="currentSeason" class="tab-panel" role="tabpanel">
    <div class="status-bar">
      <div class="status-pill">
        <span class="status-dot" id="season-latest-status-dot"></span>
        <span>Current season (2025–26) latest: <strong id="season-latest-date-label">–</strong></span>
      </div>
      <div class="status-pill">
        Safety legend:
        <span class="status-dot danger"></span><span>Thin / unsafe</span>
        <span class="status-dot warn" style="margin-left:0.5rem;"></span><span>Use caution</span>
        <span class="status-dot safe" style="margin-left:0.5rem;"></span><span>Thicker</span>
      </div>
    </div>

    <div class="summary-grid" id="current-season-grid">
      <!-- Cards injected by JS -->
    </div>
  </section>

  <!-- Current status for selected dataset -->
  <section id="current" class="tab-panel" role="tabpanel" hidden>
    <div class="status-bar">
      <div class="status-pill" id="latest-date-pill">
        <span class="status-dot" id="latest-status-dot"></span>
        <span>Latest measurements in selected dataset: <strong id="latest-date-label">–</strong></span>
      </div>
      <div class="status-pill">
        Safety legend:
        <span class="status-dot danger"></span><span>Thin / unsafe</span>
        <span class="status-dot warn" style="margin-left:0.5rem;"></span><span>Use caution</span>
        <span class="status-dot safe" style="margin-left:0.5rem;"></span><span>Thicker</span>
      </div>
    </div>

    <div class="filters" aria-label="Current status filters">
      <div class="filters-group">
        <label for="current-lake-filter">Filter by lake</label>
        <select id="current-lake-filter">
          <option value="all">All lakes</option>
        </select>
      </div>
      <div class="filters-group">
        <label for="search-filter">Search</label>
        <input type="search" id="search-filter" placeholder="Search lake or notes…" />
      </div>
    </div>

    <div class="summary-grid" id="current-grid">
      <!-- Cards injected by JS -->
    </div>

    <div class="map-card">
      <h2>Map – latest measurement by lake (selected dataset)</h2>
      <p class="map-note">Pins show the most recent reading for each lake in the selected dataset. Tap a pin for details.</p>
      <div id="map" class="map-container"></div>
    </div>
  </section>

  <!-- History & all readings -->
  <section id="history" class="tab-panel" role="tabpanel" hidden>
    <div class="chart-card">
      <div class="chart-header">
        <div class="chart-header-text">
          <h2>Ice growth by lake</h2>
          <p>Pick a lake to see how ice thickness changed over the season (selected dataset).</p>
        </div>
        <select id="chart-lake-select">
          <option value="">Select a lake…</option>
        </select>
      </div>
      <canvas id="lake-chart" height="180"></canvas>
    </div>

    <div class="filters" aria-label="History filters">
      <div class="filters-group">
        <label for="history-lake-filter">Lake</label>
        <select id="history-lake-filter">
          <option value="all">All lakes</option>
        </select>
      </div>
      <div class="filters-group">
        <label for="history-date-from">From date</label>
        <input type="date" id="history-date-from" />
      </div>
      <div class="filters-group">
        <label for="history-date-to">To date</label>
        <input type="date" id="history-date-to" />
      </div>
    </div>

    <div class="table-wrapper">
      <div class="table-scroll">
        <table>
          <thead>
            <tr>
              <th data-sort="date">Date</th>
              <th data-sort="lake">Lake</th>
              <th>Lat</th>
              <th>Long</th>
              <th data-sort="thickness_cm">Thickness</th>
              <th>Notes</th>
            </tr>
          </thead>
          <tbody id="history-tbody">
            <!-- Rows injected by JS -->
          </tbody>
        </table>
      </div>
    </div>

    <div class="download-card">
      <h2>Download ice data (Excel)</h2>
      <p>You can download the original Excel files used to build this site.</p>
      <ul id="excel-download-list"></ul>
      <p class="download-note">
        Tip: right-click a file and choose “Save link as…” if your browser tries to open it instead of downloading.
      </p>
    </div>
  </section>
</main>

<footer>
  Data collected by hand. This website is for informational and
  educational purposes only; always check local conditions and use proper safety
  gear before going on the ice.
</footer>

<!-- Leaflet JS -->
<script
  src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
  integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
  crossorigin=""
></script>

<!-- Chart.js -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

<script>
  // Datasets available on the site
  const datasetConfigs = {
    ice2024: {
      json: "Ice2024.json",
      labelShort: "2024–25"
    },
    ice2025: {
      json: "Ice2025.json",
      labelShort: "2025–26"
    },
    preice2025: {
      json: "Pre-ice-in-2025.json",
      labelShort: "Pre-ice-in 2025"
    }
  };

  // Excel files available for download
  const excelFiles = [
    { file: "Ice2024.xlsx",       label: "Ice thickness 2024–25 (Excel)" },
    { file: "Ice2025.xlsx",       label: "Ice thickness 2025–26 (Excel)" },
    { file: "Pre-ice-in-2025.xlsx", label: "Pre-ice-in 2025 (Excel)" }
  ];

  function getCurrentDatasetKey() {
    const params = new URLSearchParams(window.location.search);
    const key = params.get("dataset") || "ice2025"; // default to current season
    return datasetConfigs[key] ? key : "ice2025";
  }

  // Parse "9 1/2", "12", etc. to numeric inches
  function parseThickness(value) {
    if (value === null || value === undefined) return null;
    const raw = String(value).trim();
    if (!raw || raw === "?" || raw.toLowerCase() === "nan") return null;

    const parts = raw.split(/\s+/);
    let total = 0;
    for (const p of parts) {
      if (!p) continue;
      if (p.includes("/")) {
        const [num, den] = p.split("/");
        const n = parseFloat(num);
        const d = parseFloat(den);
        if (!isNaN(n) && !isNaN(d) && d !== 0) {
          total += n / d;
        }
      } else {
        const n = parseFloat(p);
        if (!isNaN(n)) total += n;
      }
    }
    return isNaN(total) ? null : total;
  }

  function formatDate(dateStr) {
    if (!dateStr) return "";
    const d = new Date(dateStr);
    if (isNaN(d.getTime())) return dateStr;
    return d.toLocaleDateString(undefined, { year: "numeric", month: "short", day: "numeric" });
  }

  function safetyCategory(thicknessInches) {
    if (thicknessInches === null) return { label: "Unknown", className: "", dotClass: "" };
    if (thicknessInches < 4) return { label: "Thin / unsafe", className: "unsafe", dotClass: "danger" };
    if (thicknessInches < 8) return { label: "Use caution", className: "caution", dotClass: "warn" };
    return { label: "Thicker (still use caution)", className: "safe", dotClass: "safe" };
  }

  const state = {
    data: [],
    latestDate: null,
    latestRows: [],
    currentDatasetKey: null,
    map: null,
    mapLayer: null,
    chart: null,
    // Current season (always Ice2025)
    currentSeasonData: [],
    currentSeasonLatestDate: null,
    currentSeasonLatestRows: []
  };

  async function loadData() {
    const datasetKey = getCurrentDatasetKey();
    const cfg = datasetConfigs[datasetKey];
    state.currentDatasetKey = datasetKey;

    // Load selected dataset
    const resp = await fetch(cfg.json);
    const json = await resp.json();

    const processed = json
      .map(row => {
        const date = row.date;
        const tParsed = parseThickness(row.thickness_cm);
        return {
          ...row,
          date,
          thickness_parsed: tParsed,
        };
      })
      .filter(row => row.date);

    state.data = processed;

    const dates = processed
      .map(r => new Date(r.date))
      .filter(d => !isNaN(d.getTime()));
    const maxDate = dates.length ? new Date(Math.max(...dates)) : null;
    state.latestDate = maxDate;

    state.latestRows = maxDate
      ? processed.filter(r => new Date(r.date).toDateString() === maxDate.toDateString())
      : [];

    // Load current season (Ice2025) for its dedicated tab
    await loadCurrentSeasonData();

    initFilters(processed);
    initMap();
    initChart();
    renderCurrentSeason();
    renderCurrent();
    renderHistory();
    updateMapMarkers();
    updateChartForSelectedLake();
  }

  async function loadCurrentSeasonData() {
    const cfg = datasetConfigs.ice2025;
    try {
      const resp = await fetch(cfg.json);
      const json = await resp.json();

      const processed = json
        .map(row => {
          const date = row.date;
          const tParsed = parseThickness(row.thickness_cm);
          return {
            ...row,
            date,
            thickness_parsed: tParsed,
          };
        })
        .filter(row => row.date);

      state.currentSeasonData = processed;

      const dates = processed
        .map(r => new Date(r.date))
        .filter(d => !isNaN(d.getTime()));
      const maxDate = dates.length ? new Date(Math.max(...dates)) : null;
      state.currentSeasonLatestDate = maxDate;

      state.currentSeasonLatestRows = maxDate
        ? processed.filter(r => new Date(r.date).toDateString() === maxDate.toDateString())
        : [];
    } catch (e) {
      console.error("Failed to load current season data", e);
      state.currentSeasonData = [];
      state.currentSeasonLatestDate = null;
      state.currentSeasonLatestRows = [];
    }
  }

  function initFilters(data) {
    const lakes = Array.from(new Set(data.map(r => r.lake))).sort((a, b) =>
      String(a).localeCompare(String(b))
    );

    const currentLakeSelect = document.getElementById("current-lake-filter");
    const historyLakeSelect = document.getElementById("history-lake-filter");
    const chartLakeSelect = document.getElementById("chart-lake-select");

    currentLakeSelect.innerHTML = '<option value="all">All lakes</option>';
    historyLakeSelect.innerHTML = '<option value="all">All lakes</option>';
    chartLakeSelect.innerHTML = '<option value="">Select a lake…</option>';

    for (const lake of lakes) {
      const opt1 = document.createElement("option");
      opt1.value = lake;
      opt1.textContent = lake;
      currentLakeSelect.appendChild(opt1);

      const opt2 = document.createElement("option");
      opt2.value = lake;
      opt2.textContent = lake;
      historyLakeSelect.appendChild(opt2);

      const opt3 = document.createElement("option");
      opt3.value = lake;
      opt3.textContent = lake;
      chartLakeSelect.appendChild(opt3);
    }

    if (lakes.length && !chartLakeSelect.value) {
      chartLakeSelect.value = lakes[0];
    }

    const validDates = data
      .map(r => new Date(r.date))
      .filter(d => !isNaN(d.getTime()))
      .sort((a, b) => a - b);

    if (validDates.length) {
      const min = validDates[0];
      const max = validDates[validDates.length - 1];
      const fromInput = document.getElementById("history-date-from");
      const toInput = document.getElementById("history-date-to");
      fromInput.value = min.toISOString().slice(0, 10);
      toInput.value = max.toISOString().slice(0, 10);
    }

    currentLakeSelect.addEventListener("change", () => {
      renderCurrent();
      updateMapMarkers();
    });
    document.getElementById("search-filter").addEventListener("input", renderCurrent);

    historyLakeSelect.addEventListener("change", renderHistory);
    document.getElementById("history-date-from").addEventListener("change", renderHistory);
    document.getElementById("history-date-to").addEventListener("change", renderHistory);

    chartLakeSelect.addEventListener("change", updateChartForSelectedLake);
  }

  function renderCurrentSeason() {
    const grid = document.getElementById("current-season-grid");
    grid.innerHTML = "";

    const latestLabel = document.getElementById("season-latest-date-label");
    const statusDot = document.getElementById("season-latest-status-dot");

    if (!state.currentSeasonLatestDate || !state.currentSeasonLatestRows.length) {
      latestLabel.textContent = "No data";
      statusDot.className = "status-dot";
      grid.innerHTML = "<p>No current season readings available.</p>";
      return;
    }

    latestLabel.textContent = formatDate(state.currentSeasonLatestDate.toISOString());

    const maxRisk = state.currentSeasonLatestRows.reduce((acc, r) => {
      if (r.thickness_parsed === null) return acc;
      if (r.thickness_parsed < 4) return 3;
      if (r.thickness_parsed < 8) return Math.max(acc, 2);
      return Math.max(acc, 1);
    }, 0);

    statusDot.className = "status-dot " + (maxRisk === 3 ? "danger" : maxRisk === 2 ? "warn" : "safe");

    // Group latest rows by lake
    const grouped = new Map();
    for (const r of state.currentSeasonLatestRows) {
      if (!grouped.has(r.lake)) grouped.set(r.lake, []);
      grouped.get(r.lake).push(r);
    }

    const sortedLakes = Array.from(grouped.keys()).sort((a, b) => String(a).localeCompare(String(b)));

    for (const lake of sortedLakes) {
      const group = grouped.get(lake);
      const best = group.reduce((a, b) => {
        const thA = a.thickness_parsed ?? -Infinity;
        const thB = b.thickness_parsed ?? -Infinity;
        return thB > thA ? b : a;
      }, group[0]);

      const card = document.createElement("article");
      card.className = "lake-card";

      const header = document.createElement("div");
      header.className = "lake-header";

      const lakeName = document.createElement("div");
      lakeName.className = "lake-name";
      lakeName.textContent = lake;

      const dateSpan = document.createElement("div");
      dateSpan.className = "lake-date";
      dateSpan.textContent = formatDate(best.date);

      header.appendChild(lakeName);
      header.appendChild(dateSpan);

      const thicknessDiv = document.createElement("div");
      thicknessDiv.className = "thickness";

      const thicknessValue = best.thickness_cm || "–";
      thicknessDiv.textContent = thicknessValue;
      const unitSpan = document.createElement("span");
      unitSpan.className = "unit";
      unitSpan.textContent = thicknessValue === "–" ? "" : "in";
      thicknessDiv.appendChild(unitSpan);

      const safetyInfo = safetyCategory(best.thickness_parsed);
      const safety = document.createElement("span");
      safety.className = "safety-tag " + safetyInfo.className;
      safety.textContent = safetyInfo.label;

      const meta = document.createElement("div");
      meta.className = "lake-meta";
      if (best.lat || best.long) {
        meta.textContent = [best.lat, best.long].filter(Boolean).join(" · ");
      }

      const desc = document.createElement("div");
      desc.className = "description";
      desc.textContent = best.description || "";

      card.appendChild(header);
      card.appendChild(thicknessDiv);
      card.appendChild(safety);
      if (meta.textContent) card.appendChild(meta);
      if (desc.textContent) card.appendChild(desc);

      grid.appendChild(card);
    }

    if (!grid.children.length) {
      grid.innerHTML = "<p>No readings for the current season.</p>";
    }
  }

  function renderCurrent() {
    const grid = document.getElementById("current-grid");
    grid.innerHTML = "";

    const lakeFilter = document.getElementById("current-lake-filter").value;
    const search = document.getElementById("search-filter").value.toLowerCase().trim();

    const latestDateLabel = document.getElementById("latest-date-label");
    const latestStatusDot = document.getElementById("latest-status-dot");

    if (!state.latestDate || !state.latestRows.length) {
      latestDateLabel.textContent = "No data";
      latestStatusDot.className = "status-dot";
      grid.innerHTML = "<p>No current readings available for the selected dataset.</p>";
      return;
    }

    latestDateLabel.textContent = formatDate(state.latestDate.toISOString());

    const maxRisk = state.latestRows.reduce((acc, r) => {
      if (r.thickness_parsed === null) return acc;
      if (r.thickness_parsed < 4) return 3;
      if (r.thickness_parsed < 8) return Math.max(acc, 2);
      return Math.max(acc, 1);
    }, 0);

    latestStatusDot.className = "status-dot " + (maxRisk === 3 ? "danger" : maxRisk === 2 ? "warn" : "safe");

    let rows = state.latestRows;

    if (lakeFilter !== "all") {
      rows = rows.filter(r => r.lake === lakeFilter);
    }

    if (search) {
      rows = rows.filter(r => {
        const hay = (r.lake + " " + (r.description || "")).toLowerCase();
        return hay.includes(search);
      });
    }

    const grouped = new Map();
    for (const r of rows) {
      if (!grouped.has(r.lake)) grouped.set(r.lake, []);
      grouped.get(r.lake).push(r);
    }

    const sortedLakes = Array.from(grouped.keys()).sort((a, b) => String(a).localeCompare(String(b)));

    for (const lake of sortedLakes) {
      const group = grouped.get(lake);
      const best = group.reduce((a, b) => {
        const thA = a.thickness_parsed ?? -Infinity;
        const thB = b.thickness_parsed ?? -Infinity;
        return thB > thA ? b : a;
      }, group[0]);

      const card = document.createElement("article");
      card.className = "lake-card";

      const header = document.createElement("div");
      header.className = "lake-header";

      const lakeName = document.createElement("div");
      lakeName.className = "lake-name";
      lakeName.textContent = lake;

      const dateSpan = document.createElement("div");
      dateSpan.className = "lake-date";
      dateSpan.textContent = formatDate(best.date);

      header.appendChild(lakeName);
      header.appendChild(dateSpan);

      const thicknessDiv = document.createElement("div");
      thicknessDiv.className = "thickness";

      const thicknessValue = best.thickness_cm || "–";
      thicknessDiv.textContent = thicknessValue;
      const unitSpan = document.createElement("span");
      unitSpan.className = "unit";
      unitSpan.textContent = thicknessValue === "–" ? "" : "in";
      thicknessDiv.appendChild(unitSpan);

      const safetyInfo = safetyCategory(best.thickness_parsed);
      const safety = document.createElement("span");
      safety.className = "safety-tag " + safetyInfo.className;
      safety.textContent = safetyInfo.label;

      const meta = document.createElement("div");
      meta.className = "lake-meta";
      if (best.lat || best.long) {
        meta.textContent = [best.lat, best.long].filter(Boolean).join(" · ");
      }

      const desc = document.createElement("div");
      desc.className = "description";
      desc.textContent = best.description || "";

      card.appendChild(header);
      card.appendChild(thicknessDiv);
      card.appendChild(safety);
      if (meta.textContent) card.appendChild(meta);
      if (desc.textContent) card.appendChild(desc);

      grid.appendChild(card);
    }

    if (!grid.children.length) {
      grid.innerHTML = "<p>No readings match your filters.</p>";
    }
  }

  let historySort = { key: "date", dir: "asc" };

  function renderHistory() {
    const tbody = document.getElementById("history-tbody");
    tbody.innerHTML = "";

    const lakeFilter = document.getElementById("history-lake-filter").value;
    const fromStr = document.getElementById("history-date-from").value;
    const toStr = document.getElementById("history-date-to").value;

    const from = fromStr ? new Date(fromStr) : null;
    const to = toStr ? new Date(toStr) : null;
    if (to) {
      to.setHours(23, 59, 59, 999);
    }

    let rows = state.data.slice();

    if (lakeFilter !== "all") {
      rows = rows.filter(r => r.lake === lakeFilter);
    }

    if (from) {
      rows = rows.filter(r => {
        const d = new Date(r.date);
        return !isNaN(d.getTime()) && d >= from;
      });
    }

    if (to) {
      rows = rows.filter(r => {
        const d = new Date(r.date);
        return !isNaN(d.getTime()) && d <= to;
      });
    }

    const key = historySort.key;
    const dir = historySort.dir === "asc" ? 1 : -1;

    rows.sort((a, b) => {
      const va = a[key];
      const vb = b[key];
      if (key === "date") {
        const da = new Date(va);
        const db = new Date(vb);
        return (da - db) * dir;
      }
      if (key === "thickness_cm") {
        const ta = parseThickness(a.thickness_cm) ?? -Infinity;
        const tb = parseThickness(b.thickness_cm) ?? -Infinity;
        return (ta - tb) * dir;
      }
      return String(va).localeCompare(String(vb)) * dir;
    });

    for (const r of rows) {
      const tr = document.createElement("tr");

      const tdDate = document.createElement("td");
      tdDate.textContent = formatDate(r.date);
      tr.appendChild(tdDate);

      const tdLake = document.createElement("td");
      tdLake.textContent = r.lake;
      tr.appendChild(tdLake);

      const tdLat = document.createElement("td");
      tdLat.textContent = r.lat || "";
      tr.appendChild(tdLat);

      const tdLong = document.createElement("td");
      tdLong.textContent = r.long || "";
      tr.appendChild(tdLong);

      const tdThick = document.createElement("td");
      tdThick.textContent = r.thickness_cm || "";
      tr.appendChild(tdThick);

      const tdDesc = document.createElement("td");
      tdDesc.textContent = r.description || "";
      tr.appendChild(tdDesc);

      tbody.appendChild(tr);
    }

    if (!tbody.children.length) {
      const tr = document.createElement("tr");
      const td = document.createElement("td");
      td.colSpan = 6;
      td.textContent = "No readings match your filters.";
      tr.appendChild(td);
      tbody.appendChild(tr);
    }
  }

  function initTabs() {
    const buttons = document.querySelectorAll(".tab-button");
    const panels = document.querySelectorAll(".tab-panel");

    buttons.forEach(btn => {
      btn.addEventListener("click", () => {
        const tab = btn.dataset.tab;
        buttons.forEach(b => b.classList.toggle("active", b === btn));
        panels.forEach(p => {
          p.hidden = p.id !== tab;
        });
        if (tab === "current" && state.map) {
          setTimeout(() => state.map.invalidateSize(), 0);
        }
      });
    });
  }

  function initHistorySorting() {
    const headers = document.querySelectorAll("thead th[data-sort]");
    headers.forEach(th => {
      th.addEventListener("click", () => {
        const key = th.dataset.sort;
        if (historySort.key === key) {
          historySort.dir = historySort.dir === "asc" ? "desc" : "asc";
        } else {
          historySort.key = key;
          historySort.dir = "asc";
        }
        renderHistory();
      });
    });
  }

  function initMap() {
    if (state.map) return;
    const mapEl = document.getElementById("map");
    if (!mapEl) return;

    state.map = L.map(mapEl).setView([44.96, -93.29], 12);

    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 18,
      attribution: "&copy; OpenStreetMap contributors"
    }).addTo(state.map);

    state.mapLayer = L.layerGroup().addTo(state.map);
  }

  function updateMapMarkers() {
    if (!state.map || !state.mapLayer) return;

    state.mapLayer.clearLayers();

    const lakeFilter = document.getElementById("current-lake-filter").value;

    let rows = state.latestRows.slice();
    if (lakeFilter !== "all") {
      rows = rows.filter(r => r.lake === lakeFilter);
    }

    const grouped = new Map();
    for (const r of rows) {
      if (!grouped.has(r.lake)) grouped.set(r.lake, []);
      grouped.get(r.lake).push(r);
    }

    const markers = [];

    grouped.forEach((group, lake) => {
      const best = group.reduce((a, b) => {
        const thA = a.thickness_parsed ?? -Infinity;
        const thB = b.thickness_parsed ?? -Infinity;
        return thB > thA ? b : a;
      }, group[0]);

      const lat = parseFloat(best.lat);
      const lng = parseFloat(best.long);
      if (isNaN(lat) || isNaN(lng)) return;

      const safety = safetyCategory(best.thickness_parsed);
      let color = "#4cd964";
      if (safety.className === "caution") color = "#ffc857";
      if (safety.className === "unsafe") color = "#ff4f6a";

      const marker = L.circleMarker([lat, lng], {
        radius: 7,
        weight: 2,
        color: color,
        fillColor: color,
        fillOpacity: 0.7
      }).addTo(state.mapLayer);

      marker.bindPopup(
        `<strong>${lake}</strong><br>` +
        `${formatDate(best.date)}<br>` +
        `Thickness: ${best.thickness_cm || "–"} in<br>` +
        `<small>${safety.label}</small>`
      );

      markers.push(marker);
    });

    if (markers.length) {
      const group = L.featureGroup(markers);
      state.map.fitBounds(group.getBounds().pad(0.2));
    }
  }

  function initChart() {
    const ctx = document.getElementById("lake-chart");
    if (!ctx) return;
    if (state.chart) {
      state.chart.destroy();
    }

    state.chart = new Chart(ctx, {
      type: "line",
      data: {
        labels: [],
        datasets: [
          {
            label: "Ice thickness (inches)",
            data: [],
            tension: 0.25,
            pointRadius: 3,
            pointHoverRadius: 4,
            borderWidth: 2
          }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          x: {
            ticks: {
              autoSkip: true,
              maxTicksLimit: 8
            }
          },
          y: {
            title: {
              display: true,
              text: "Thickness (inches)"
            },
            beginAtZero: true
          }
        },
        plugins: {
          legend: { display: false },
          tooltip: {
            callbacks: {
              label: function(context) {
                const value = context.parsed.y;
                return ` ${value.toFixed(2)} in`;
              }
            }
          }
        }
      }
    });
  }

  function updateChartForSelectedLake() {
    if (!state.chart) return;

    const lakeSelect = document.getElementById("chart-lake-select");
    const lake = lakeSelect.value;
    const chart = state.chart;

    if (!lake) {
      chart.data.labels = [];
      chart.data.datasets[0].data = [];
      chart.update();
      return;
    }

    const rows = state.data
      .filter(r => r.lake === lake && r.thickness_parsed !== null)
      .sort((a, b) => new Date(a.date) - new Date(b.date));

    const labels = rows.map(r => formatDate(r.date));
    const values = rows.map(r => r.thickness_parsed);

    chart.data.labels = labels;
    chart.data.datasets[0].data = values;
    chart.update();
  }

  function renderExcelDownloads() {
    const listEl = document.getElementById("excel-download-list");
    if (!listEl) return;

    listEl.innerHTML = "";

    if (!excelFiles.length) {
      const li = document.createElement("li");
      li.textContent = "No Excel files are currently available.";
      listEl.appendChild(li);
      return;
    }

    excelFiles.forEach(item => {
      const li = document.createElement("li");
      const a = document.createElement("a");
      a.href = item.file;
      a.download = "";
      a.textContent = item.label || item.file;
      li.appendChild(a);
      listEl.appendChild(li);
    });
  }

  document.addEventListener("DOMContentLoaded", () => {
    initTabs();
    initHistorySorting();
    renderExcelDownloads();

    // Set dataset select to URL param
    const datasetSelectEl = document.getElementById("dataset-select");
    if (datasetSelectEl) {
      const currentKey = getCurrentDatasetKey();
      datasetSelectEl.value = currentKey;

      datasetSelectEl.addEventListener("change", () => {
        const key = datasetSelectEl.value;
        const params = new URLSearchParams(window.location.search);
        params.set("dataset", key);
        window.location.search = params.toString();
      });
    }

    loadData().catch(err => {
      console.error("Failed to load data:", err);
      const grid = document.getElementById("current-grid");
      if (grid) {
        grid.innerHTML = "<p>Could not load data JSON. Make sure the JSON files are in the same folder as index.html.</p>";
      }
    });
  });
</script>
</body>
</html>